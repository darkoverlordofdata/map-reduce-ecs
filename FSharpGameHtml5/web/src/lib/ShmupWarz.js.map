{"version":3,"sources":["..\\..\\..\\lib\\ShmupWarz.fs"],"names":[],"mappings":"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","file":"ShmupWarz.js","sourcesContent":["ï»¿module ShmupWarz\r\n\r\n(** ShmupWarz Game Demo *)\r\nopen Fable.Core\r\nopen Fable.Import\r\nopen Fable.Import.Browser\r\nopen Fable.Core.JsInterop\r\nopen Mouse\r\nopen Keyboard\r\nopen Color\r\n\r\n(** src:Core.fs *)\r\n\r\n(** Abstrct Game *)\r\n[<AbstractClass>]\r\ntype Game(width, height, images) as this =\r\n    let mutable previousTime = 0.0\r\n    let mutable elapsedTime = 0.0\r\n    let mutable totalFrames = 0\r\n    let renderer = PIXI.WebGLRenderer(width, height)\r\n    do document.body.appendChild(renderer.view) |> ignore        \r\n    let rec animate timeStamp =\r\n        let t = if previousTime>0.0 then previousTime else timeStamp\r\n        previousTime <- timeStamp\r\n        let delta = (timeStamp - t) * 0.001\r\n        totalFrames <- totalFrames + 1\r\n        elapsedTime <- elapsedTime + delta\r\n        if elapsedTime > 1.0 then\r\n            this.fps <- totalFrames\r\n            totalFrames <- 0\r\n            elapsedTime <- 0.0\r\n\r\n        window.requestAnimationFrame(FrameRequestCallback animate) |> ignore\r\n        this.Update(delta)\r\n        this.Draw(delta)\r\n        renderer.render(this.spriteBatch)\r\n    member val spriteBatch = PIXI.Container()\r\n    member val fps = 0 with get,set\r\n    [<DefaultValue>]val mutable Content:obj\r\n    member this.Initialize() =\r\n        this.LoadContent()\r\n    abstract member LoadContent: unit -> unit\r\n    abstract member Update: float -> unit\r\n    abstract member Draw: float -> unit\r\n    member this.Run() =\r\n        for (a, b) in images do PIXI.Globals.loader?add(a, b) |> ignore    \r\n        PIXI.Globals.loader.load(System.Func<_,_,_>(fun loader resources ->\r\n            this.Content <- resources\r\n            this.Initialize()\r\n            animate 0. |> ignore\r\n        ))\r\n\r\n(** src:Components.fs *)\r\n\r\n(** Layer - All entities need a display layer *)\r\ntype Layer =\r\n    | DEFAULT           = 0\r\n    | BACKGROUND        = 1\r\n    | TEXT              = 2\r\n    | LIVES             = 3\r\n    | ENEMY1            = 4\r\n    | ENEMY2            = 5\r\n    | ENEMY3            = 6\r\n    | PLAYER            = 7\r\n    | BULLET            = 8\r\n    | EXPLOSION         = 9\r\n    | BANG              = 10\r\n    | PARTICLE          = 11\r\n    | HUD               = 12\r\n\r\n(** EntityType Component *)\r\ntype EntityType =\r\n    | Background        = 0\r\n    | Bullet            = 1\r\n    | Enemy             = 2\r\n    | Explosion         = 3\r\n    | Particle          = 4\r\n    | Player            = 5\r\n\r\n(** Sound Effect Component *)\r\ntype Effect =\r\n    | PEW               = 0\r\n    | ASPLODE           = 1\r\n    | SMALLASPLODE      = 2\r\n\r\n(** Enemy Type Component *)\r\ntype Enemies =\r\n    | Enemy1            = 0\r\n    | Enemy2            = 1\r\n    | Enemy3            = 2\r\n\r\n(** Health Component *)\r\ntype Health =\r\n    {\r\n        CurHealth: int;\r\n        MaxHealth: int;\r\n    }\r\n\r\n(** Create a Health Component *)\r\nlet CreateHealth(curHealth: int, maxHealth : int) =\r\n    {\r\n        CurHealth = curHealth;\r\n        MaxHealth = maxHealth;\r\n    }\r\n\r\n(** Tween Component *)\r\ntype Tween =\r\n    {\r\n        Min : float;\r\n        Max : float;\r\n        Speed : float;\r\n        Repeat : bool;\r\n        Active : bool;\r\n    }\r\n(** Create a Scale Animation Component *)\r\nlet CreateTween(min: float, max: float, speed: float, repeat: bool, active: bool) =\r\n    {\r\n        Min = min;\r\n        Max = max;\r\n        Speed = speed;\r\n        Repeat = repeat;\r\n        Active = active;\r\n    } \r\n\r\n\r\n\r\n(** Request an enemy *)\r\ntype EnemyQueItem =\r\n    {\r\n        Enemy : Enemies;\r\n    }\r\nlet EnemyQue(enemy : Enemies) : EnemyQueItem =\r\n    {\r\n        Enemy = enemy;\r\n    }\r\n\r\n\r\n(** Request an explosion *)\r\ntype ExplosionQueItem =\r\n    {\r\n        X: float;\r\n        Y: float;\r\n        Scale : float;\r\n    }\r\nlet ExplosionQue(x:float, y:float, scale : float) : ExplosionQueItem =\r\n    {\r\n        X = x;\r\n        Y = y;\r\n        Scale = scale;\r\n    }\r\n\r\n(** Request a bullet *)\r\ntype BulletQueItem =\r\n    {\r\n        X: float;\r\n        Y: float;\r\n    }\r\nlet BulletQue(x:float, y:float) : BulletQueItem =\r\n    {\r\n        X = x;\r\n        Y = y;\r\n    }\r\n    \r\n(** src:Entity.fs *)\r\n(**\r\n * Entity Factory\r\n *\r\n *)\r\n\r\nlet rnd = System.Random()\r\nlet mutable UniqueId = 0\r\nlet NextUniqueId() = \r\n    UniqueId <- UniqueId + 1\r\n    UniqueId\r\n\r\n(** Entity is a record of components *)\r\ntype Entity = \r\n    {\r\n        Id              : int;                  (* Unique sequential id *)\r\n        Name            : string;               (* Display name *)\r\n        Active          : bool;                 (* In use *)\r\n        EntityType      : EntityType;           (* Category *)\r\n        Layer           : Layer;                (* Display Layer *)\r\n        Position        : PIXI.Point;           (* Position *)\r\n        Sprite          : PIXI.Sprite option;   (* Sprite *)\r\n        Scale           : PIXI.Point option;    (* Display Scale *)\r\n        Tint            : Color option;         (* Color to use as tint *)\r\n        Bounds          : int option;           (* For Hit Detection *)\r\n        Expires         : float option;         (* Entity duration *)\r\n        Health          : Health option;        (* Points *)\r\n        Tween           : Tween option;         (* Explosion tweens *)\r\n        Size            : PIXI.Point;           (* Sprite size *)\r\n        Velocity        : PIXI.Point option;    (* Movement speed *)\r\n    }\r\n\r\n(** Create a Player Entity *)\r\nlet CreatePlayer (content:obj, x: float, y: float) =\r\n    let position = PIXI.Point(0., 0.)\r\n    let sprite = PIXI.Sprite(unbox content?fighter?texture)\r\n    sprite.anchor <- PIXI.Point(0.5, 0.5)\r\n    {\r\n        Id = NextUniqueId();\r\n        Name = \"Player\";\r\n        Active = true;\r\n        EntityType = EntityType.Player; \r\n        Layer = Layer.PLAYER;\r\n        Position = position; \r\n        Scale = None;\r\n        Sprite = Some(sprite);\r\n        Tint = None;\r\n\r\n        Bounds = Some(43);\r\n        Expires = None;\r\n        Health = Some(CreateHealth(100, 100));\r\n        Velocity = Some(PIXI.Point(0., 0.));\r\n        Tween = None;\r\n        Size = PIXI.Point(float sprite.width, float sprite.height);\r\n    }\r\n     \r\n(** Create a Bullet Entity *)\r\nlet CreateBullet (content:obj, x: float, y: float) =\r\n    let position = PIXI.Point(x, y)\r\n    let sprite = PIXI.Sprite(unbox content?bullet?texture)\r\n    sprite.anchor <- PIXI.Point(0.5, 0.5)\r\n    {\r\n        Id = NextUniqueId();\r\n        Name = \"Bullet\";\r\n        Active = false;\r\n        EntityType = EntityType.Bullet; \r\n        Layer = Layer.BULLET;\r\n        Position = position; \r\n        Scale = None;\r\n        Sprite = Some(sprite);\r\n        Tint = Some(Color.GreenYellow);\r\n\r\n        Bounds = Some(5);\r\n        Expires = Some(0.1);\r\n        Health = None;\r\n        Velocity = Some(PIXI.Point(0., -800.));\r\n        Tween = None;\r\n        Size = PIXI.Point(float sprite.width, float sprite.height);\r\n    }\r\n\r\n(** Create Enemy *)\r\nlet CreateEnemy1 (content:obj, width: int, height: int)  =\r\n    let position = PIXI.Point(float(rnd.Next(width)), 100.)\r\n    let sprite = PIXI.Sprite(unbox content?enemy1?texture)\r\n    sprite.anchor <- PIXI.Point(0.5, 0.5)\r\n    {\r\n        Id = NextUniqueId();\r\n        Name = \"Enemy1\";\r\n        Active = false;\r\n        EntityType = EntityType.Enemy; \r\n        Layer = Layer.ENEMY1;\r\n        Position = position; \r\n        Scale = None;\r\n        Sprite = Some(sprite);\r\n        Tint = None;\r\n\r\n        Bounds = Some(20);\r\n        Expires = None\r\n        Health = Some(CreateHealth(10, 10));\r\n        Velocity = Some(PIXI.Point(0., 40.));\r\n        Tween = None;\r\n        Size = PIXI.Point(float sprite.width, float sprite.height);\r\n    }\r\n(** Create Enemy *)\r\nlet CreateEnemy2 (content:obj, width: int, height: int) =\r\n    let position = PIXI.Point(float(rnd.Next(width)), 200.)\r\n    let sprite = PIXI.Sprite(unbox content?enemy2?texture)\r\n    sprite.anchor <- PIXI.Point(0.5, 0.5)\r\n    {\r\n        Id = NextUniqueId();\r\n        Name = \"Enemy2\";\r\n        Active = false;\r\n        EntityType = EntityType.Enemy; \r\n        Layer = Layer.ENEMY2;\r\n        Position = position; \r\n        Scale = None;\r\n        Sprite = Some(sprite);\r\n        Tint = None;\r\n\r\n        Bounds = Some(40);\r\n        Expires = None\r\n        Health = Some(CreateHealth(20, 20));\r\n        Velocity = Some(PIXI.Point(0., 30.));\r\n        Tween = None;\r\n        Size = PIXI.Point(float sprite.width, float sprite.height);\r\n    }\r\n\r\n(** Create Enemy *)\r\nlet CreateEnemy3 (content:obj, width: int, height: int)  =\r\n    let position = PIXI.Point(float(rnd.Next(width)), 300.)\r\n    let sprite = PIXI.Sprite(unbox content?enemy3?texture)\r\n    sprite.anchor <- PIXI.Point(0.5, 0.5)\r\n    {\r\n        Id = NextUniqueId();\r\n        Name = \"Enemy3\";\r\n        Active = false;\r\n        EntityType = EntityType.Enemy; \r\n        Layer = Layer.ENEMY3;\r\n        Position = position; \r\n        Scale = None;\r\n        Sprite = Some(sprite);\r\n        Tint = None;\r\n\r\n        Bounds = Some(70);\r\n        Expires = None\r\n        Health = Some(CreateHealth(60, 60));\r\n        Velocity = Some(PIXI.Point(0., 20.));\r\n        Tween = None;\r\n        Size = PIXI.Point(float sprite.width, float sprite.height);\r\n    }\r\n\r\n(** Create Big Explosion *)\r\nlet CreateExplosion (content:obj, x: float, y: float, scale:float) =\r\n    let position = PIXI.Point(x, y)\r\n    let sprite = PIXI.Sprite(unbox content?explosion?texture)\r\n    sprite.anchor <- PIXI.Point(0.5, 0.5)\r\n    {\r\n        Id = NextUniqueId();\r\n        Name = \"Explosion\";\r\n        Active = false;\r\n        EntityType = EntityType.Explosion; \r\n        Layer = Layer.EXPLOSION;\r\n        Position = position; \r\n        Scale = Some(PIXI.Point(scale, scale))\r\n        Sprite = Some(sprite);\r\n        Tint = Some(Color.LightGoldenrodYellow);\r\n\r\n        Bounds = None;\r\n        Expires = Some(0.5);\r\n        Health = None;\r\n        Velocity = None;\r\n        Tween = Some(CreateTween(scale/100., scale, -3., false, true));\r\n        Size = PIXI.Point(float sprite.width, float sprite.height);\r\n    }\r\n\r\nlet CreateBang (content:obj, x: float, y: float, scale:float) =\r\n    let position = PIXI.Point(x, y)\r\n    let sprite = PIXI.Sprite(unbox content?bang?texture)\r\n    sprite.anchor <- PIXI.Point(0.5, 0.5)\r\n    {\r\n        Id = NextUniqueId();\r\n        Name = \"Bang\";\r\n        Active = false;\r\n        EntityType = EntityType.Explosion; \r\n        Layer = Layer.BANG;\r\n        Position = position; \r\n        Scale = Some(PIXI.Point(scale, scale))\r\n        Sprite = Some(sprite);\r\n        Tint = Some(Color.PaleGoldenrod);\r\n\r\n        Bounds = None;\r\n        Expires = Some(0.5);\r\n        Health = None;\r\n        Velocity = None;\r\n        Tween = Some(CreateTween(scale/100., scale, -3., false, true));\r\n        Size = PIXI.Point(float sprite.width, float sprite.height);\r\n    }\r\n\r\n(**\r\n * Create the Entity DataBase\r\n *) \r\nlet CreateEntityDB(content, width, height) = \r\n    [\r\n        CreatePlayer(content, 0., 0.);\r\n        CreateBang(content, 0., 0., 1.);\r\n        CreateBang(content, 0., 0., 1.);\r\n        CreateBang(content, 0., 0., 1.);\r\n        CreateBang(content, 0., 0., 1.);\r\n        CreateBang(content, 0., 0., 1.);\r\n        CreateBang(content, 0., 0., 1.);\r\n        CreateBang(content, 0., 0., 1.);\r\n        CreateBang(content, 0., 0., 1.);\r\n        CreateExplosion(content, 0., 0., 1.);\r\n        CreateExplosion(content, 0., 0., 1.);\r\n        CreateExplosion(content, 0., 0., 1.);\r\n        CreateExplosion(content, 0., 0., 1.);\r\n        CreateExplosion(content, 0., 0., 1.);\r\n        CreateExplosion(content, 0., 0., 1.);\r\n        CreateExplosion(content, 0., 0., 1.);\r\n        CreateExplosion(content, 0., 0., 1.);\r\n        CreateBullet(content, 0., 0.);\r\n        CreateBullet(content, 0., 0.);\r\n        CreateBullet(content, 0., 0.);\r\n        CreateBullet(content, 0., 0.);\r\n        CreateBullet(content, 0., 0.);\r\n        CreateBullet(content, 0., 0.);\r\n        CreateBullet(content, 0., 0.);\r\n        CreateBullet(content, 0., 0.);\r\n        CreateBullet(content, 0., 0.);\r\n        CreateBullet(content, 0., 0.);\r\n        CreateBullet(content, 0., 0.);\r\n        CreateBullet(content, 0., 0.);\r\n        CreateBullet(content, 0., 0.);\r\n        CreateBullet(content, 0., 0.);\r\n        CreateBullet(content, 0., 0.);\r\n        CreateBullet(content, 0., 0.);\r\n        CreateBullet(content, 0., 0.);\r\n        CreateBullet(content, 0., 0.);\r\n        CreateBullet(content, 0., 0.);\r\n        CreateBullet(content, 0., 0.);\r\n        CreateBullet(content, 0., 0.);\r\n        CreateBullet(content, 0., 0.);\r\n        CreateBullet(content, 0., 0.);\r\n        CreateEnemy1(content, 0, 0);\r\n        CreateEnemy1(content, 0, 0);\r\n        CreateEnemy1(content, 0, 0);\r\n        CreateEnemy1(content, 0, 0);\r\n        CreateEnemy1(content, 0, 0);\r\n        CreateEnemy1(content, 0, 0);\r\n        CreateEnemy1(content, 0, 0);\r\n        CreateEnemy1(content, 0, 0);\r\n        CreateEnemy1(content, 0, 0);\r\n        CreateEnemy2(content, 0, 0);\r\n        CreateEnemy2(content, 0, 0);\r\n        CreateEnemy2(content, 0, 0);\r\n        CreateEnemy2(content, 0, 0);\r\n        CreateEnemy2(content, 0, 0);\r\n        CreateEnemy2(content, 0, 0);\r\n        CreateEnemy3(content, 0, 0);\r\n        CreateEnemy3(content, 0, 0);\r\n        CreateEnemy3(content, 0, 0);\r\n        CreateEnemy3(content, 0, 0);\r\n\r\n    ]\r\n\r\n\r\n(** src:Entities.fs *)\r\n(**\r\n * The abstract EscGame provides interface and lists to\r\n * use for adding and removing entities\r\n * This allows systems to hold a forward reference to the game object\r\n *)\r\n[<AbstractClass>]\r\ntype EcsGame(height, width, images) =\r\n    inherit Game(height, width, images)\r\n    member val Bullets = List.empty<BulletQueItem> with get,set\r\n    member val Deactivate = List.empty<int> with get,set\r\n    member val Enemies1 = List.empty<EnemyQueItem> with get,set\r\n    member val Enemies2 = List.empty<EnemyQueItem> with get,set\r\n    member val Enemies3 = List.empty<EnemyQueItem> with get,set\r\n    member val Explosions = List.empty<ExplosionQueItem> with get,set\r\n    member val Bangs = List.empty<ExplosionQueItem> with get,set\r\n\r\n    abstract member AddBullet : float * float -> unit\r\n    abstract member AddEnemy : Enemies -> unit \r\n    abstract member AddExplosion : float * float * float -> unit\r\n    abstract member AddBang : float * float * float -> unit\r\n    abstract member RemoveEntity: int -> unit\r\n\r\n(**\r\n * Returns a list of active entities for drawing.\r\n * No need to rev the returned list, they will be sorted by layer.\r\n *)\r\nlet ActiveEntities (input:Entity list) =\r\n    let rec _activeEntities (input:Entity list) (output:Entity list) =\r\n        match input with\r\n        | x::xs when x.Active -> _activeEntities xs (x::output)\r\n        | _::xs -> _activeEntities xs output \r\n        | [] -> output\r\n    _activeEntities input []\r\n\r\n(** src:Systems/EntitySystem.fs *)\r\n(**\r\n * Activate / Deactiveate Entities as needed \r\n *)\r\nlet EntitySystem (game:EcsGame, width: int, height: int) entity =\r\n\r\n    match entity.Active with\r\n    | true -> \r\n        let mutable removed = false\r\n        let rec removeIf l predicate =\r\n            match l with\r\n            | [] -> []\r\n            | x::rest -> \r\n                if predicate(x) then \r\n                    removed <- true\r\n                    (removeIf rest predicate) \r\n                else \r\n                    x::(removeIf rest predicate)\r\n\r\n        let len = game.Deactivate.Length\r\n        game.Deactivate <- (removeIf game.Deactivate (fun id -> id = entity.Id))\r\n        {\r\n            entity with \r\n                Active = not removed;\r\n        }\r\n\r\n    | false -> \r\n        match entity.Layer with\r\n        | Layer.BULLET ->\r\n            match game.Bullets with\r\n            | [] -> entity\r\n            | bullet :: rest ->\r\n                game.Bullets <- rest\r\n                {            \r\n                    entity with\r\n                        Active = true;\r\n                        Expires = Some(0.5);                        \r\n                        Position = PIXI.Point(bullet.X, bullet.Y);\r\n                }\r\n        | Layer.ENEMY1 ->\r\n            match game.Enemies1 with\r\n            | [] -> entity\r\n            | enemy :: rest ->\r\n               game.Enemies1 <- rest\r\n               {\r\n                    entity with \r\n                        Active = true;\r\n                        Position = PIXI.Point(float(rnd.Next(width-35)), 91./2.0);\r\n                        Health = Some(CreateHealth(10, 10));\r\n                }\r\n        | Layer.ENEMY2 ->\r\n            match game.Enemies2 with\r\n            | [] -> entity\r\n            | enemy :: rest ->\r\n                game.Enemies2 <- rest\r\n                {\r\n                    entity with \r\n                        Active = true;\r\n                        Position = PIXI.Point(float(rnd.Next(width-86)), 172./2.);\r\n                        Health = Some(CreateHealth(20, 20));                \r\n                }\r\n        | Layer.ENEMY3 ->\r\n            match game.Enemies3 with\r\n            | [] -> entity\r\n            | enemy :: rest ->\r\n                game.Enemies3 <- rest\r\n                {\r\n                    entity with \r\n                        Active = true;\r\n                        Position = PIXI.Point(float(rnd.Next(width-160)), 320./2.);\r\n                        Health = Some(CreateHealth(60, 60));                \r\n                }\r\n        | Layer.EXPLOSION ->\r\n            match game.Explosions with\r\n            | [] -> entity\r\n            | exp :: rest ->\r\n                game.Explosions <- rest\r\n                {\r\n                    entity with \r\n                        Active = true;\r\n                        Expires = Some(0.2);                        \r\n                        Scale = Some(PIXI.Point(exp.Scale, exp.Scale));\r\n                        Position = PIXI.Point(exp.X, exp.Y);\r\n                }\r\n        | Layer.BANG ->\r\n            match game.Bangs with\r\n            | [] -> entity\r\n            | exp :: rest ->\r\n                game.Bangs <- rest\r\n                {\r\n                    entity with \r\n                        Active = true;\r\n                        Expires = Some(0.2);                        \r\n                        Scale = Some(PIXI.Point(exp.Scale, exp.Scale));\r\n                        Position = PIXI.Point(exp.X, exp.Y);\r\n                }\r\n        | _ -> entity\r\n\r\n(** src:Systems/CollisionSystem.fs *)\r\n(** Return Rect defining the current bounds *)\r\nlet BoundingRect(entity) =\r\n    let x = entity.Position.x\r\n    let y = entity.Position.y\r\n    let w = entity.Size.x\r\n    let h = entity.Size.y\r\n    PIXI.Rectangle(x - w/2., y - h/2., w, h):>PIXI.HitArea\r\n\r\n(** Collision Handler for Entities *)\r\nlet CollisionSystem (game:EcsGame) entities =\r\n\r\n    let findCollision a b =\r\n        match a.EntityType, a.Active, b.EntityType, b.Active with\r\n        | EntityType.Enemy, true, EntityType.Bullet, true -> \r\n            game.AddBang(b.Position.x, b.Position.y, 1.0)\r\n            game.RemoveEntity(b.Id)\r\n            match a.Health with\r\n            | Some(h) ->\r\n                let health = h.CurHealth-1\r\n                if health <= 0 then\r\n                    game.AddExplosion(b.Position.x, b.Position.y, 0.5)\r\n                    {\r\n                        a with\r\n                            Active = false;\r\n                    }\r\n                else\r\n                    {\r\n                        a with \r\n                            Health = Some(CreateHealth(health, h.MaxHealth));\r\n                    }\r\n\r\n            | None -> a\r\n        | _ -> a\r\n\r\n    let rec figureCollisions (entity:Entity) (sortedEntities:Entity list) =\r\n        match sortedEntities with\r\n        | [] -> entity\r\n        | x :: xs -> \r\n            let a = if (BoundingRect(entity).contains(x.Position.x, x.Position.y)) then\r\n                        findCollision entity x\r\n                    else\r\n                        entity\r\n            figureCollisions a xs\r\n\r\n    let rec fixCollisions (toFix:Entity list) (alreadyFixed:Entity list) =\r\n        match toFix with\r\n        | [] -> alreadyFixed\r\n        | x :: xs -> \r\n            let a = figureCollisions x alreadyFixed\r\n            fixCollisions xs (a::alreadyFixed)\r\n\r\n    fixCollisions entities []\r\n\r\n(** src:Systems/EnemySpawningSystem.fs *)\r\ntype Timers =\r\n    | Timer1 = 2\r\n    | Timer2 = 7\r\n    | Timer3 = 13\r\n\r\nlet mutable enemyT1 = float(Timers.Timer1)\r\nlet mutable enemyT2 = float(Timers.Timer2)\r\nlet mutable enemyT3 = float(Timers.Timer3)\r\n\r\nlet EnemySpawningSystem (delta:float, game:EcsGame)  =\r\n    let spawnEnemy (t:float, enemy) =\r\n        let delta = t - delta\r\n\r\n        if delta < 0.0 then\r\n            game.AddEnemy(enemy)\r\n            match enemy with\r\n            | Enemies.Enemy1 -> float(Timers.Timer1)\r\n            | Enemies.Enemy2 -> float(Timers.Timer2)\r\n            | Enemies.Enemy3 -> float(Timers.Timer3)\r\n            | _ -> 0.0\r\n        else delta\r\n\r\n    enemyT1 <- spawnEnemy(enemyT1, Enemies.Enemy1)\r\n    enemyT2 <- spawnEnemy(enemyT2, Enemies.Enemy2)\r\n    enemyT3 <- spawnEnemy(enemyT3, Enemies.Enemy3)\r\n    \r\n(** src:Systems/InputSystem.fs *)\r\nlet mutable timeToFire = 0.0\r\n(** Get Player Input *)\r\nlet InputSystem (delta:float, mobile:bool, game:EcsGame) entity =\r\n    let pf = if mobile then 2.0 else 1.0\r\n    match entity.EntityType with\r\n    | EntityType.Player -> \r\n\r\n        let position =\r\n            let newPosition = Mouse.position\r\n            if Keyboard.isPressed 90 then\r\n                timeToFire <- timeToFire - delta\r\n                if timeToFire <= 0.0 then\r\n                    game.AddBullet(newPosition.x-27.0, newPosition.y)\r\n                    game.AddBullet(newPosition.x+27.0, newPosition.y)\r\n                    timeToFire <- 0.1\r\n                newPosition\r\n            else\r\n                if Mouse.down then\r\n                    timeToFire <- timeToFire - delta\r\n                    if timeToFire <= 0.0 then\r\n                        game.AddBullet(newPosition.x-27.0, newPosition.y)\r\n                        game.AddBullet(newPosition.x+27.0, newPosition.y)\r\n                        timeToFire <- 0.1\r\n                    newPosition\r\n                else\r\n                    newPosition\r\n\r\n        (* Set Player Position *)\r\n        { entity with Position = position;  }\r\n    | _ ->\r\n        entity\r\n\r\n(** src:Systems/MovementSystem.fs *)\r\n(** Movement System *)\r\nlet MovementSystem (delta:float) entity =\r\n\r\n    match entity.Velocity, entity.Active with\r\n\r\n    | Some(velocity), true ->\r\n        let x = entity.Position.x + velocity.x * delta\r\n        let y = entity.Position.y + velocity.y * delta\r\n        { entity with Position = PIXI.Point(float x, float y)}\r\n\r\n    | _ -> entity\r\n\r\n\r\n(** src:Systems/ExpiringSSystem.fs *)\r\n(** \r\n * Expiring System \r\n *\r\n * Destroy entities when their time is up\r\n *)\r\nlet ExpiringSystem (delta:float) entity =\r\n    match entity.Expires, entity.Active with\r\n    | Some(v), true ->\r\n        let exp = v - delta\r\n        let active = if exp > 0. then true else false\r\n        { \r\n            entity with \r\n                Expires = Some(exp);\r\n                Active = active;\r\n        }\r\n    | _ -> entity\r\n\r\n\r\n(** src:Systems/RemoveOffscreenShipsSystem.fs *)\r\nlet RemoveOffscreenShipsSystem (game:EcsGame, width: int, height: int) entity =\r\n    match entity.EntityType, entity.Active with\r\n    | EntityType.Enemy, true when int entity.Position.y > height ->\r\n        { \r\n            entity with \r\n                Active = false;\r\n        }\r\n    | _ -> entity\r\n\r\n(** src:Systems/TweenSystem.fs *)\r\nlet TweenSystem (delta:float, game:EcsGame) entity =\r\n    match (entity.Scale, entity.Tween, entity.Active) with\r\n    | Some(scale), Some(sa), true ->        \r\n        let mutable x = scale.x + (sa.Speed * delta)\r\n        let mutable y =  scale.y + (sa.Speed * delta)\r\n        let mutable active = sa.Active\r\n        if x > sa.Max then\r\n            x <- sa.Max\r\n            y <- sa.Max\r\n            active <- false\r\n        elif x < sa.Min then\r\n            x <- sa.Min\r\n            y <- sa.Min\r\n            active <- false\r\n\r\n        {\r\n            entity with\r\n                Scale = Some(PIXI.Point(x, y));\r\n                Tween = Some(CreateTween(sa.Min, sa.Max, sa.Speed, sa.Repeat, active));\r\n        }\r\n\r\n    | _ -> \r\n        entity\r\n\r\n\r\n(** src:ShmupWarzGame.fs *)\r\n(** ShmupWarz *)\r\ntype ShmupWarz(height, width0, mobile) as this =\r\n    inherit EcsGame(height, width0, [\r\n                            (\"background\", \"images/BackdropBlackLittleSparkBlack.png\");\r\n                            (\"bang\", \"images/bang.png\");\r\n                            (\"bullet\", \"images/bullet.png\");\r\n                            (\"enemy1\",\"images/enemy1.png\");\r\n                            (\"enemy2\",\"images/enemy2.png\");\r\n                            (\"enemy3\",\"images/enemy3.png\");\r\n                            (\"explosion\",\"images/explosion.png\");\r\n                            (\"fighter\",\"images/fighter.png\")\r\n                            (\"font\",\"images/tom-thumb-white.png\")\r\n        ])\r\n    let pixelFactor = (if mobile then 2.0 else 1.0)\r\n    let width = ((float)width0/pixelFactor)\r\n    let mutable entities = lazy(CreateEntityDB(this.Content, int width, int height))\r\n    let fntImage = lazy(PIXI.Sprite(unbox this.Content?font?texture))\r\n    let bgdImage = lazy(PIXI.Sprite(unbox this.Content?background?texture))\r\n    let bgdRect = PIXI.Rectangle(0., 0., width, height)\r\n    let scaleX = (float) (width / 320.) // pixelFactor\r\n    let scaleY = (float) (height / 480.) // pixelFactor\r\n\r\n    (** Draw the sprite for an Entity *)\r\n    let drawSprite(spriteBatch:PIXI.Container) (entity) =\r\n        match entity.Sprite with\r\n        | Some sprite ->\r\n            let scale =\r\n                match entity.Scale with\r\n                | Some(scale) -> scale\r\n                | None -> PIXI.Point(1., 1.)\r\n            let color = \r\n                match entity.Tint with \r\n                | Some(color) -> color\r\n                | None -> Color.White\r\n            sprite.x <- entity.Position.x\r\n            sprite.y <- entity.Position.y\r\n            sprite.scale <- scale\r\n            sprite.tint <- float color\r\n            spriteBatch.addChild(sprite) |> ignore\r\n\r\n        | None -> ()\r\n\r\n    member this.Initialize() =\r\n        base.Initialize()\r\n\r\n    override this.LoadContent() =\r\n        entities.Force() |> ignore\r\n        ()\r\n\r\n    override this.Draw(gameTime) =        \r\n        this.spriteBatch.children?length <- 0\r\n        this.spriteBatch.addChild(bgdImage.Value) |> ignore\r\n        ActiveEntities(entities.Value)\r\n        |> List.sortBy(fun e -> e.Layer) \r\n        |> List.iter(drawSprite(this.spriteBatch))\r\n        ()\r\n\r\n    override this.Update(gameTime) =\r\n        //  if GamePad.GetState(PlayerIndex.One).Buttons.Back = ButtonState.Pressed then \r\n        //     this.Exit()\r\n        let delta = gameTime\r\n        let current = entities.Value\r\n\r\n        EnemySpawningSystem(delta, this) |> ignore\r\n        entities <-  // Everything happens here:\r\n            lazy (current\r\n                 |> List.map(InputSystem(delta, mobile, this))\r\n                 |> List.map(EntitySystem(this, int width, int height))\r\n                 |> List.map(MovementSystem(delta))\r\n                 |> List.map(ExpiringSystem(delta))\r\n                 |> List.map(TweenSystem(delta, this))\r\n                 |> List.map(RemoveOffscreenShipsSystem(this, int width, int height))\r\n                 |> CollisionSystem(this)\r\n                 )\r\n\r\n        // pick up the list when we draw\r\n        //this.entityList <- ActiveEntities (entities.Force())\r\n       \r\n    (** Deactivate an Entity *)\r\n    override this.RemoveEntity(id:int) =\r\n        this.Deactivate <- id :: this.Deactivate\r\n\r\n    (** Que a Bullet *)\r\n    override this.AddBullet(x: float, y:float) =\r\n        this.Bullets <- BulletQue(x, y) :: this.Bullets\r\n        //Browser.console.log(\"AddBullet\", x, y, this.Bullets.Length)\r\n\r\n    (** Que a Enemy *)\r\n    override this.AddEnemy(enemy : Enemies) =\r\n        match enemy with \r\n        | Enemies.Enemy1 -> this.Enemies1 <- EnemyQue(enemy) :: this.Enemies1\r\n        | Enemies.Enemy2 -> this.Enemies2 <- EnemyQue(enemy) :: this.Enemies2\r\n        | Enemies.Enemy3 -> this.Enemies3 <- EnemyQue(enemy) :: this.Enemies3\r\n        | _ -> ()\r\n\r\n    (** Que an Explosion *)\r\n    override this.AddExplosion(x: float, y:float, scale : float) =\r\n        this.Explosions <- ExplosionQue(x, y, scale) :: this.Explosions\r\n\r\n    (** Que an Bang *)\r\n    override this.AddBang(x: float, y:float, scale : float) =\r\n        this.Bangs <- ExplosionQue(x, y, scale) :: this.Bangs\r\n\r\n\r\nKeyboard.init()\r\nMouse.init()\r\nlet game = ShmupWarz(320.*1.5, 480.*1.5, false)\r\ngame.Run() |> ignore\r\n\r\n\r\n"]}